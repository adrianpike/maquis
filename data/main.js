/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webjack/dist/webjack.js":
/*!**********************************************!*\
  !*** ./node_modules/webjack/dist/webjack.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var WebJack = {};\n\n(function(exports){\n\n  if (false)\n    {}\n  else \n    module.exports = WebJack;\n\n})( false? undefined: exports);\n\n/* From http://ejohn.org/blog/simple-javascript-inheritance/ */\n\n/* Simple JavaScript Inheritance\n * By John Resig http://ejohn.org/\n * MIT Licensed.\n */\n// Inspired by base2 and Prototype\n(function(){\n  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n \n  // The base Class implementation (does nothing)\n  this.Class = function(){};\n \n  // Create a new Class that inherits from this class\n  Class.extend = function(prop) {\n    var _super = this.prototype;\n   \n    // Instantiate a base class (but only create the instance,\n    // don't run the init constructor)\n    initializing = true;\n    var prototype = new this();\n    initializing = false;\n   \n    // Copy the properties over onto the new prototype\n    for (var name in prop) {\n      // Check if we're overwriting an existing function\n      prototype[name] = typeof prop[name] == \"function\" &&\n        typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n        (function(name, fn){\n          return function() {\n            var tmp = this._super;\n           \n            // Add a new ._super() method that is the same method\n            // but on the super-class\n            this._super = _super[name];\n           \n            // The method only need to be bound temporarily, so we\n            // remove it when we're done executing\n            var ret = fn.apply(this, arguments);        \n            this._super = tmp;\n           \n            return ret;\n          };\n        })(name, prop[name]) :\n        prop[name];\n    }\n   \n    // The dummy class constructor\n    function Class() {\n      // All construction is actually done in the init method\n      if ( !initializing && this.init )\n        this.init.apply(this, arguments);\n    }\n   \n    // Populate our constructed prototype object\n    Class.prototype = prototype;\n   \n    // Enforce the constructor to be what we expect\n    Class.prototype.constructor = Class;\n \n    // And make this class extendable\n    Class.extend = arguments.callee;\n   \n    return Class;\n  };\n})();\n\nWebJack.Decoder = Class.extend({\n\n  init: function(args) {\n\n    var decoder = this;\n\n    var DEBUG = args.debug;\n    var csvContent = '';\n    \n    var onReceive = args.onReceive;\n    var raw;\n\n    var sampleRate = args.sampleRate;\n\n    var baud, freqLow, freqHigh;\n    var samplesPerBit, preambleLength;\n\n    var cLowReal, cLowImag, cHighReal, cHighImag;\n    var sinusLow, sinusHigh, cosinusLow, cosinusHigh;\n\n    var state = {\n      current  : 0,\n      PREAMBLE : 1,\n      START    : 2,\n      DATA     : 3,\n      STOP     : 4,\n\n      bitCounter : 0,  // counts up to 8 bits\n      byteBuffer : 0,  // where the 8 bits get assembled\n      wordBuffer : [], // concat received chars\n\n      lastTransition : 0,\n      lastBitState : 0,\n      t : 0, // sample counter, no reset currently -> will overflow\n      c : 0  // counter for the circular correlation arrays\n    };\n\n    decoder.setProfile = function(profile) {\n      baud = profile.baud;\n      freqLow = profile.freqLow;\n      freqHigh = profile.freqHigh;\n\n      samplesPerBit = Math.ceil(sampleRate/baud);\n      preambleLength = Math.ceil(sampleRate*40/1000/samplesPerBit);\n\n\n      cLowReal = new Float32Array(samplesPerBit/2);\n      cLowImag = new Float32Array(samplesPerBit/2);\n      cHighReal = new Float32Array(samplesPerBit/2);\n      cHighImag = new Float32Array(samplesPerBit/2);\n\n      sinusLow = new Float32Array(samplesPerBit/2);\n      sinusHigh = new Float32Array(samplesPerBit/2);\n      cosinusLow = new Float32Array(samplesPerBit/2);\n      cosinusHigh = new Float32Array(samplesPerBit/2);\n\n      (function initCorrelationArrays(){\n        var phaseIncLow = 2*Math.PI * (freqLow/sampleRate);\n        var phaseIncHigh = 2*Math.PI * (freqHigh/sampleRate);\n        for(var i = 0; i < samplesPerBit/2; i++){\n          sinusLow[i] = Math.sin(phaseIncLow * i);\n          sinusHigh[i] = Math.sin(phaseIncHigh * i);\n          cosinusLow[i] = Math.cos(phaseIncLow * i);\n          cosinusHigh[i] = Math.cos(phaseIncHigh * i);\n        }\n      })();\n\n      raw = typeof profile.raw === 'undefined' ? false : profile.raw;\n    }\n    decoder.setProfile(args);\n\n\n    function normalize(samples){\n      var max = Math.max.apply(null, samples);\n      for (var i = 0; i < samples.length; i++){\n        samples[i] /= max;\n      }\n    }\n\n    function sum(array){\n      var s = 0;\n      for(var i = 0; i < array.length; i++){\n        s += array[i];\n      }\n      return s;\n    }\n\n    function smoothing(samples, n){\n      for(var i = n; i < samples.length - n; i++){\n        for(var o = -n; o <= n; o++){\n          samples[i] += samples[i+o];\n        }\n        samples[i] /= (n*2)+1;\n        if (DEBUG) csvContent += samples[i] + '\\n';\n      }\n    }\n\n    function demod(smpls){\n      var samples = smpls;\n      var symbols = [];\n      var cLow, cHigh;\n\n      normalize(samples);\n\n      // correlation\n      var s = state.c;\n      for(var i = 0; i < samples.length; i++){\n        cLowReal[s] = samples[i] * cosinusLow[s];\n        cLowImag[s] = samples[i] * sinusLow[s];\n        cHighReal[s] = samples[i] * cosinusHigh[s];\n        cHighImag[s] = samples[i] * sinusHigh[s];\n\n        cLow = Math.sqrt( Math.pow( sum(cLowReal), 2) + Math.pow( sum(cLowImag), 2) );\n        cHigh = Math.sqrt( Math.pow( sum(cHighReal), 2) + Math.pow( sum(cHighImag), 2) );\n        samples[i] = cHigh - cLow;\n\n        s++;\n        if (s == samplesPerBit/2)\n          s = 0;\n      }\n      state.c = s;\n\n      smoothing(samples, 1);\n\n      // discriminate bitlengths\n      for(var i = 1; i < samples.length; i++){\n        \n        if ((samples[i] * samples[i-1] < 0) || (samples[i-1] == 0)){\n          var bits = Math.round((state.t - state.lastTransition)/ samplesPerBit);\n          state.lastTransition = state.t;\n          symbols.push(bits);\n        }\n        state.t++;\n      }\n      state.t++;\n      return symbols;\n    }\n\n    function addBitNTimes(bit, n) {\n      if (state.bitCounter + n > 8)\n        throw 'byteBuffer too small';\n      for (var b = 0; b < n; b++){\n        state.bitCounter++;\n        state.byteBuffer >>>= 1;\n        if (bit)\n          state.byteBuffer |= 128;\n        if (state.bitCounter == 8) {\n          state.wordBuffer.push(state.byteBuffer);\n          state.byteBuffer = 0;\n        }\n      }\n    }\n\n    function emitString(buffer) {\n      var word = '';\n      if (buffer.length) {\n        buffer.forEach(function(octet) {\n          word += String.fromCharCode(octet);\n        });\n        buffer.length = 0;\n      }\n      onReceive(word);\n    }\n    var emit = raw ? onReceive : emitString;\n\n    decoder.decode = function(samples){\n      // start of time measurement\n      // var a = performance.now();\n\n      var bitlengths = demod(samples);\n\n      var nextState = state.PREAMBLE;\n\n      for(var i = 0; i < bitlengths.length ; i++) {\n        var symbols = bitlengths[i];\n        // if (DEBUG) console.log(symbols);\n        switch (state.current){\n\n          case state.PREAMBLE:\n            if (symbols >= 12 && symbols <= preambleLength + 20){\n            // if (symbols >= preambleLength -3  && symbols <= preambleLength + 20) {\n              nextState = state.START;\n              state.lastBitState = 0;\n              state.byteBuffer = 0;\n              state.wordBuffer = [];\n            }\n            break;\n\n          case state.START:\n            if (DEBUG) console.log('START');\n            state.bitCounter = 0;\n            if (symbols == 1)\n              nextState = state.DATA;\n            else if (symbols > 1 && symbols <= 9){\n              nextState = symbols == 9 ? state.STOP : state.DATA;\n              addBitNTimes(0, symbols - 1);\n            } \n            else \n              nextState = state.PREAMBLE;\n            break;\n\n          case state.DATA:\n            if (DEBUG) console.log('DATA');\n            var bits_total = symbols + state.bitCounter;\n            var bit = state.lastBitState ^ 1;\n\n            if (bits_total > 11) {\n              nextState = state.PREAMBLE;\n            } else if (bits_total == 11){ // all bits high, stop bit, push bit, preamble\n              addBitNTimes(1, symbols - 3);\n              nextState = state.START;\n              if (DEBUG) console.log('>emit< ' + state.wordBuffer[0].toString(2));\n              emit(state.wordBuffer);\n              state.wordBuffer = [];\n            } else if (bits_total == 10) { // all bits high, stop bit, push bit, no new preamble\n              addBitNTimes(1, symbols - 2);\n              nextState = state.PREAMBLE;\n              if (DEBUG) console.log('|emit| ' + state.wordBuffer[0].toString(2));\n              emit(state.wordBuffer);\n            } else if (bits_total == 9) { // all bits high, stop bit, no push bit\n              addBitNTimes(1, symbols - 1);\n              nextState = state.START;\n            } else if (bits_total == 8) {\n              addBitNTimes(bit, symbols);\n              nextState = state.STOP;\n              state.lastBitState = bit;\n            } else {\n              addBitNTimes(bit, symbols);\n              nextState = state.DATA;\n              state.lastBitState = bit;\n            }\n\n            if (symbols == 0){ // 0 always indicates a misinterpreted symbol\n              nextState = state.PREAMBLE;\n              if (DEBUG) console.log('#demod error#');\n            }\n            break;\n\n          case state.STOP:\n            if (DEBUG) console.log(' STOP');\n            if (symbols == 1) {\n              nextState = state.START;\n            } else if (symbols == 3) {\n              nextState = state.START;\n              if (DEBUG) console.log('>>emit<< ' + state.wordBuffer[0].toString(2));\n              emit(state.wordBuffer);\n              state.wordBuffer = [];\n            } else if (symbols >= 2) {  \n              nextState = state.PREAMBLE;\n              if (DEBUG) console.log('||emit|| ' + state.wordBuffer[0].toString(2));\n              emit(state.wordBuffer);\n            } else\n              nextState = state.PREAMBLE;\n\n            break;\n\n          default:\n            nextState = state.PREAMBLE;\n            state.bitCounter = 0;\n            state.byteBuffer = 0;\n        }\n        state.current = nextState;\n      }\n      // end of time measurement\n      // console.log('audio event decode time: ' + Math.round(performance.now()-a) + \" ms\");\n\n      // if (state.t >= 441000 && DEBUG) { // download demodulated signal after ~10 sec\n      //  downloadDemodulatedData();\n      //  DEBUG = false;\n      // } \n    }\n\n    // for debugging: download demodulated signal as CSV file\n    function downloadDemodulatedData(){\n      var blob = new Blob([csvContent], {type: 'text/csv;charset=utf-8;'});\n      var url = URL.createObjectURL(blob)\n      var link = document.createElement('a');\n      link.setAttribute('href', url);\n      link.setAttribute('download', 'data.csv');\n      link.click();\n    }\n  }\n});\nWebJack.Encoder = Class.extend({\n\n  init: function(args) {\n\n    var encoder = this;\n\n    var sampleRate = 44100;\n    var targetSampleRate = args.sampleRate;\n    \n    var baud;\n    var freqLow;\n    var freqHigh;\n\n    var samplesPerBit;\n    var preambleLength;\n    var pushbitLength;\n\n    var bitBufferLow;\n    var bitBufferHigh;\n\n    var rawStream;\n    var softmodem;\n\n    encoder.setProfile = function(profile){\n\n      baud = profile.baud;\n      freqLow = profile.freqLow;\n      freqHigh = profile.freqHigh;\n\n      samplesPerBit = Math.ceil(sampleRate/baud);\n      preambleLength = Math.ceil(sampleRate*40/1000/samplesPerBit);\n      pushbitLength =  profile.softmodem ? 1 : 2;\n\n      bitBufferLow = new Float32Array(samplesPerBit);\n      bitBufferHigh = new Float32Array(samplesPerBit);\n\n      rawStream = typeof profile.raw === 'undefined' ? false : profile.raw;      \n      softmodem = profile.softmodem;\n\n      (function generateBitBuffers(){\n        var phaseIncLow = 2 * Math.PI * freqLow / sampleRate;\n        var phaseIncHigh = 2 * Math.PI * freqHigh / sampleRate;\n        \n        for (var i=0; i < samplesPerBit; i++) {\n          bitBufferLow.set( [Math.cos(phaseIncLow*i)], i);\n          bitBufferHigh.set( [Math.cos(phaseIncHigh*i)], i);\n        }\n      })();\n      console.log(\"new encoder profile: \",  profile);\n    }\n    encoder.setProfile(args);\n\n    function toUTF8(str) {\n      var utf8 = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charCodeAt(i);\n        if (c <= 0x7f)\n          utf8.push(c);\n        else if (c <= 0x7ff) {\n          utf8.push(0xc0 | (c >>> 6));\n          utf8.push(0x80 | (c & 0x3f));\n        } else if (c <= 0xffff) {\n          utf8.push(0xe0 | (c >>> 12));\n          utf8.push(0x80 | ((c >>> 6) & 0x3f));\n          utf8.push(0x80 | (c & 0x3f));\n        } else {\n          var j = 4;\n          while (c >>> (6*j))\n            j++;\n          utf8.push(((0xff00 >>> j) & 0xff) | (c >>> (6*--j)));\n          while (j--) \n            utf8[idx++] = 0x80 | ((c >>> (6*j)) & 0x3f);\n        }\n      }\n      return utf8;\n    }\n\n    encoder.modulate = function(data){\n      var uint8 = rawStream ? data : toUTF8(data);\n      var bufferLength = (preambleLength + 10*(uint8.length) + pushbitLength)*samplesPerBit;\n      var samples = new Float32Array(bufferLength);\n\n      var i = 0;\n      function pushBits(bit, n){\n        for (var k = 0; k < n; k++){\n          samples.set(bit ? bitBufferHigh : bitBufferLow, i);\n          i += samplesPerBit;\n        }\n      }\n\n      pushBits(1, preambleLength);\n      for (var x = 0; x < uint8.length; x++) {\n        var c = (uint8[x] << 1) | 0x200;\n        for (var b = 0; b < 10; b++, c >>= 1)\n          pushBits( c&1, 1);\n      }\n      pushBits(1, 1);\n      if (!softmodem)\n        pushBits(0, 1);\n\n      if (args.debug) console.log(\"gen. audio length: \" +samples.length);\n      var resampler = new WebJack.Resampler({inRate: sampleRate, outRate: targetSampleRate, inputBuffer: samples});\n      resampler.resample(samples.length);\n      var resampled = resampler.outputBuffer();\n      // console.log(samples);\n      if (args.debug) console.log(\"resampled audio length: \" + resampled.length);\n      // console.log(resampled);\n\n      return resampled;\n    }\n  }\n});\nWebJack.Profiles = {\n  // default SoftModem frequencies, no echo cancellation to avoid attenuation\n  SoftModem : { \n    baud : 1225,\n    freqLow : 4900,\n    freqHigh : 7350,\n    echoCancellation : false,\n    softmodem : true\n  },\n  // lower frequencies and echo cancellation: try this to reduce crosstalk for long cables\n  SoftModemLowFrequencies : { \n    baud : 1225,\n    freqLow : 2450,\n    freqHigh : 4900,\n    echoCancellation : true,\n    softmodem : true\n  },\n  // browser-to-browser, over-the-air transmission profile\n  Browser : { \n    baud : 1225,\n    freqLow : 19600,\n    freqHigh : 20825,\n    echoCancellation : false,\n    softmodem : false\n  }\n}\n// JavaScript Audio Resampler by Grant Galitz\n// from https://github.com/taisel/XAudioJS/blob/master/resampler.js\n// simplified for single channel usage\n\nWebJack.Resampler = Class.extend({\n\n  init: function(args) {\n\n    var resampler = this;\n\n    var fromSampleRate = +args.inRate;\n    var toSampleRate = +args.outRate;\n    var inputBuffer = args.inputBuffer;\n    var outputBuffer;\n    var ratioWeight, lastWeight, lastOutput, tailExists;\n    var resampleFunction;\n\n    if (typeof inputBuffer != \"object\") {\n      throw(new Error(\"inputBuffer is not an object.\"));\n    }\n    if (!(inputBuffer instanceof Array) \n      && !(inputBuffer instanceof Float32Array) \n      && !(inputBuffer instanceof Float64Array)) {\n      throw(new Error(\"inputBuffer is not an array or a float32 or a float64 array.\"));\n    }\n    \n    if (fromSampleRate > 0 && toSampleRate > 0) {\n      if (fromSampleRate == toSampleRate) {\n        resampleFunction = bypassResampler;        //Resampler just returns what was passed through.\n        ratioWeight = 1;\n        outputBuffer = inputBuffer;\n      }\n      else {\n        initializeBuffers();\n        ratioWeight = fromSampleRate / toSampleRate;\n        if (fromSampleRate < toSampleRate) {\n          resampleFunction = linearInterpolationFunction;\n          lastWeight = 1;\n        }\n        else {\n          resampleFunction = compileMultiTapFunction;\n          tailExists = false;\n          lastWeight = 0;\n        }\n      }\n    }\n    else {\n      throw(new Error(\"Invalid settings specified for the resampler.\"));\n    }\n    \n    function linearInterpolationFunction(bufferLength) {\n      var outputOffset = 0;\n      if (bufferLength > 0) {\n        var weight = lastWeight;\n        var firstWeight = 0;\n        var secondWeight = 0;\n        var sourceOffset = 0;\n        var outputOffset = 0;\n\n        weight -= 1;\n        for (bufferLength -= 1, sourceOffset = Math.floor(weight); sourceOffset < bufferLength;) {\n          secondWeight = weight % 1;\n          firstWeight = 1 - secondWeight; \n          outputBuffer[outputOffset++] = (inputBuffer[sourceOffset] * firstWeight)\n           + (inputBuffer[sourceOffset + 1] * secondWeight); \n          weight += ratioWeight;\n          sourceOffset = Math.floor(weight);\n        } \n        lastOutput[0] = inputBuffer[sourceOffset++]; \n        lastWeight = weight % 1;\n      }\n      return outputOffset;\n    }\n\n    function compileMultiTapFunction() {\n      var outputOffset = 0;\n      if (bufferLength > 0) {\n        var weight = 0; \n        var output0 = 0; \n        var actualPosition = 0;\n        var amountToNext = 0;\n        var alreadyProcessedTail = !tailExists;\n        tailExists = false;\n        var currentPosition = 0;\n        do {\n          if (alreadyProcessedTail) {\n            weight = ratioWeight;\n            output0 = 0;\n          }\n          else {\n            weight = lastWeight;\n            output0 = lastOutput[0];\n            alreadyProcessedTail = true;\n          }\n          while (weight > 0 && actualPosition < bufferLength) {\n            amountToNext = 1 + actualPosition - currentPosition;\n            if (weight >= amountToNext) {\n              output0 += inputBuffer[actualPosition++] * amountToNext;\n              currentPosition = actualPosition;\n              weight -= amountToNext;\n            }\n            else {\n              output0 += inputBuffer[actualPosition] * weight;\n              currentPosition += weight;\n              weight = 0;\n              break;\n            }\n          }\n          if (weight <= 0) {\n            outputBuffer[outputOffset++] = output0 / ratioWeight;\n          }\n          else {\n            lastWeight = weight;\n            lastOutput[0] = output0;\n            tailExists = true;\n            break;\n          }\n        } while (actualPosition < bufferLength);\n      }\n      return outputOffset;\n    }\n\n    function bypassResampler(upTo) {\n      return upTo;\n    }\n    \n    function initializeBuffers() {\n      var outputBufferSize = Math.ceil(inputBuffer.length * toSampleRate / fromSampleRate / 1.000000476837158203125) + 1;\n      try {\n        outputBuffer = new Float32Array(outputBufferSize);\n        lastOutput = new Float32Array(1);\n      }\n      catch (error) {\n        outputBuffer = [];\n        lastOutput = [];\n      }\n    }\n\n    resampler.resample = function(bufferLength){\n      return resampleFunction(bufferLength);\n    }\n\n    resampler.outputBuffer = function(){\n      return outputBuffer;\n    }\n  }\n});\n'use strict';\n\nWebJack.Connection = Class.extend({\n\n  init: function(args) {\n\n    var connection = this;\n\n\n    function ifUndef(arg, Default){\n      return typeof arg === 'undefined' ? Default : arg;\n    }\n\n    var args = ifUndef(args, WebJack.Profiles.SoftModem);\n    var AudioContext = window.AudioContext || window.webkitAudioContext;\n    var audioCtx = ifUndef(args.audioCtx, new AudioContext());\n\n    var opts = connection.options = {\n      sampleRate       : audioCtx.sampleRate,\n      baud             : ifUndef(args.baud, 1225),\n      freqLow          : ifUndef(args.freqLow, 4900),\n      freqHigh         : ifUndef(args.freqHigh, 7350),\n      debug            : ifUndef(args.debug, false),\n      softmodem        : ifUndef(args.softmodem, true),\n      raw              : ifUndef(args.raw, false),\n      echoCancellation : ifUndef(args.echoCancellation, false)\n    };\n\n    var encoder = new WebJack.Encoder(opts);\n    var decoder;\n    var rxCallback;\n\n    function onAudioProcess(event) {\n      var buffer = event.inputBuffer;\n      var samplesIn = buffer.getChannelData(0);\n      console.log(\"-- audioprocess data (\" + samplesIn.length + \" samples) --\");\n\n      if (!decoder){\n        opts.onReceive = rxCallback;\n        decoder = new WebJack.Decoder(opts);\n      }\n      decoder.decode(samplesIn);\n    }\n\n    function successCallback(stream) {\n      var audioTracks = stream.getAudioTracks();\n      console.log('Using audio device: ' + audioTracks[0].label);\n      console.log(\"-- samplerate (\" + opts.sampleRate + \") --\");\n      if (!stream.active) {\n        console.log('Stream not active');\n      }\n      audioSource = audioCtx.createMediaStreamSource(stream);\n      decoderNode = audioCtx.createScriptProcessor(8192, 1, 1); // buffersize, input channels, output channels\n      audioSource.connect(decoderNode);\n      decoderNode.addEventListener(\"audioprocess\", onAudioProcess);\n      decoderNode.connect(audioCtx.destination); // Chrome does not fire events without destination \n    }\n\n    function errorCallback(error) {\n      console.log('navigator.getUserMedia error: ', error);\n    }\n\n    navigator = args.navigator || navigator;\n    navigator.mediaDevices.getUserMedia(\n      {\n        audio: {\n            optional: [{ echoCancellation: opts.echoCancellation }]\n        },\n        video: false\n      }\n    ).then(\n      successCallback,\n      errorCallback\n    );\n\n\n    // an object containing two histories -- \n    // sent commands and received commands\n    connection.history = {\n\n      // oldest first:\n      sent: [],\n\n      // oldest first:\n      received: []\n\n    }\n\n    var queue = [];\n    var locked = false;\n\n    // Sends data to device\n    connection.send = function(data) {\n      \n      function playAudioBuffer(buffer) {\n        var bufferNode = audioCtx.createBufferSource();\n        bufferNode.buffer = buffer;\n        bufferNode.connect(audioCtx.destination);\n        locked = true;\n        bufferNode.start(0);\n        bufferNode.onended = function() {\n          locked = false;\n          if (queue.length)\n            playAudioBuffer(queue.shift());\n        }\n      }\n\n\n      var samples = encoder.modulate(data);\n      var dataBuffer = audioCtx.createBuffer(1, samples.length, opts.sampleRate);\n      dataBuffer.getChannelData(0).set(samples);\n\n\n      if (locked)\n        queue.push(dataBuffer);\n      else\n        playAudioBuffer(dataBuffer);\n\n      connection.history.sent.push(data);\n    }\n\n\n    // Listens for data packets and runs \n    // passed function listener() on results\n    connection.listen = function(listener) {\n      rxCallback = function(data){\n        listener(data);\n        connection.history.received.push(data);\n      };\n    }    \n\n\n    // Returns valid JSON object if possible, \n    // or <false> if not.\n    connection.validateJSON = function(data) {\n      var object; \n      try {\n        object = JSON.parse(data);\n      } catch (e) {\n        return false;\n      }\n      return object;\n    }\n\n    // Set the connection profile\n    connection.setProfile = function(profile) {\n      encoder.setProfile(profile);\n      if (typeof decoder === 'object')\n        decoder.setProfile(profile);\n    }\n\n  } \n\n});\n\n\n//# sourceURL=webpack:///./node_modules/webjack/dist/webjack.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This is all placeholder for now\n// Not gonna use React for size reasons, but will use or build something, don't you worry.\n\nconst WebJack = __webpack_require__(/*! webjack */ \"./node_modules/webjack/dist/webjack.js\");\nconst profile = {\n  baud: 1200,\n  freqLow: 1200,\n  freqHigh: 2200,\n  echoCancellation: false,\n  softmodem: false\n};\nconst audioConnection = new WebJack.Connection(profile);\n\nclass MaquisClient {\n  constructor() {\n\n  }\n}\n\nwindow.ac = audioConnection;\n\nfunction deliverMessage(message) {\n  if (ws.connected) {\n    ws.send(message);\n  }\n\n  if (audioConnection) {\n    audioConnection.send(message);\n  }\n}\n\nlet ws = new WebSocket(`ws://${location.host}/ws`);\nconst form = document.createElement('form');\ndocument.body.appendChild(form); \n  \nconst input = document.createElement('input');\nform.appendChild(input);\n\nform.addEventListener('submit', function(e) {\n  e.preventDefault();\n  deliverMessage(input.value);\n  return false;\n});\n\nconst output = document.createElement('textarea');\ndocument.body.appendChild(output);\n\nws.addEventListener('message', function(evt) {\n  output.innerHTML += \"\\n\" + evt.data;\n});\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });